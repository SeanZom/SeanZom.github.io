---
title: Kotlin 基础
date: 2018-06-01
toc: true
categories:
  - Android
tags:
  - kotlin
---


## 基本类型

### Numbers

- 每个数值类型都支持下面的转换：`toByte(), toShort(), toInt(), toFloat(), toLong(), toDouble(), toChar()`

### Arrays

- `arrayOf()` 创建Array

- `arrayOfNulls()` 创建指定大小的空数组

- 使用工厂函数创建例子：

  ````kotlin
  val asc = Array(5, {i -> (i * i).toString()}) // ["0", "1", "4", "9", "16"]
  ````

### Strings

- string 可以通过索引操作读取：`s[i]`
- string 可以用 for 循环迭代： `for (c in str) { println(c) }`
- 可以用三个双引号(`"""`) 创建 raw string
- `trimMargin()` 用来移除起始前缀，默认起始前缀是 (`|`), 可以给该方法输入参数指定其他字符作为起始前缀
- 字符串模板: 如果需要使用原始字符 $（不支持反斜杠转移），可以使用语法：`${'$'}9.99` 

#### 常用方法

- `.isNullOrBlank()`
- `.isBlank()`
- `.isNullOrEmpty()`
- `.isEmpty()`

## Packages

- 如果出现命名冲突，可以使用 `as` 关键字来局部重命名解决冲突
- `import` 不局限于导入类；还可以用来导入其他声明：
    1. 顶级函数与属性
    2. 在对象声明中声明的函数和属性
    3. 枚举常量

## 语句和流程控制（Control Flow）

### is 

- 判断一个对象是否为一个类的实例，与 java 中的 `instanceof` 类似
- 可以取反 `!is`
- 做过类型判断后，对象会被系统自动转换成比对的类型，在判断代码块外部的该对象依然是原始类型的引用

```kotlin
    fun getStrLen(obj: Any) : Int? {
        if (obj is String) {
            // 做过类型判断后，obj 会被系统自动转换为 String 类型
            return obj.length
        }

        // 代码块外部的 obj 依然是 Any 类型的引用
        return null
    }
```

### as

> 用于类型的强转换

- 如果 smart cast(智能转换) 的对象是一个==全局变量==，这个变量可能在别的地方被改变赋值，所以必须手动判断与转换它的类型

```kotlin
open class Animal
class Dog: Animal {
    fun bark() = println("animal")
}
var animal: Animal? = null
fun main(args: Array<String>) {
    if (animal is Dog) {
        // 并不满足执行的条件，所以不会执行以下语句
        (animal as Dog).bark()
    }
}
```
### const

- 只能作用于原始类型（primitives）和 `Strings`

### let, apply, with, run, also

| Function | Function type | Target passed as | Returns            |
| :------- | ------------- | ---------------- | ------------------ |
| `also`   | extension     | `it`             | target             |
| `apply`  | extension     | `this`           | target             |
| `let`    | extension     | `it`             | block return value |
| `run`    | extension     | `this`           | block return value |
| `with`   | regular       | `this`           | block return value |

#### apply

可以集中初始化新对象实例的属性，可以在需要对新对象多个属性赋值时省略重复书写属性名

#### let

- 非空执行

- 可以适当地使用 `let` 来代替 `if` 实现相同的效果（不过切勿滥用）

  ```kotlin
  val order: Order? = findOrder()
  if (order != null) {
      dun(order.customer)
  }
  
  // with let
  findOrder()?.let{
      dum(it.customer)
  }
  // or
  findOrder()?.costomer?.let(::dum)
  ```

### var VS val 

- `var`：可修改

- `val`：read-only

  ```kotlin
  val simple: Int? // has type Int, default getter, must be initialized in constructor
  val inferredType = 1 // has type Int and a default getter
  ```

- val: 作为类参数如果被 val 声明并设置了默认值，如果在新建对象实例的时候没有传入对应的参数，则该实例的属性为已设置的默认值；如果传入了参数，参数就会赋值到属性上去

### in 关键字

>  判断一个对象是否在某一个区间内（比如`array`，集合之类的）

### if 表达式

> Kotlin 中的 if 表达式可以很好地取代三目运算符，所以 Kotlin 中已经不存在三目运算符

- `if` 既可以作为 statement 也可以作为表达式(expression) 来使用

- 取代三目运算符：`val max = if (a > b) a else b`。 if 的分支可以是==块级==的，最后一个表达式就是这个块的值

    ```kotlin
    val max = if (a > b) {
        print("Choose a")
        a
    } else {
        print("Choose b")
        b
    }
    ```

- 如果 `if` 作为表达式来使用的话，必须包含 `else` 分支，分支可以是块级的。如果使用的是大括号包含的块级，分块里最后一行是作为值的

### When 表达式

> when 取代了 switch 运算符

- `when` 可以用作==表达式==或者==声明==
- 如果 `when` 是用作表达式的话，除非编译器可以检验存在的 `cases` 可以囊括了所有的可能性，否则`else`分支是强制性需要的
- 可以使用任意表达式作为分支条件
- 可以使用 `in` 或者 `!in` 来检查一个值是否在一个范围内或一个集合中
- 使用 `is` 或者 `!is` 来判断值是否是某个类型

### try  catch 表达式

> Kotlin 中 try catch 可以作为表达式来使用

## 返回与跳转 - Returns and Jumps

- Kotlin 中任意表达式可以添加标签 label(`@`)
- `break` 和 `continue` 可以利用 label 实现快速精确的跳转: `break@myLabel`

### 正则表达式

- 创建实例：
  1. `Regex("a[bc]+d?")`
  2. `"a[bc]+d?".toRegex()` 为了避免出现转码错误更推荐使用 raw String: `"""a[bc]+d?\W""".toRegex()`
  3. `Regex.fromLiteral("a[bc]+d?")`

### 算子 - Elvis Operator  `?:`

```kotlin
// 用来代替 if-else 判空
val l : Int = if (b != null) b.length else -1
// 使用 算子
val = b?.length ?: -1

// 也可以用于中的空值处理
// throw 和 return 在 Kotlin 中成为了表达式
fun foo(node: Node): String? {
    val parent = node.getParent() ?: return null
    val name = node.getName() ?: throw IllegalArgumentException("name expected")
}
```
## Lambda

- Lambda 表达式最大的特点是可以作为参数传递

### Lambda 语法糖

- 当参数只有一个的时候，声明中可以不用显式声明参数，在使用参数时可以用 `it` 来替代那个唯一的参数

- 当有用不到的参数时，可以用下划线 (`_ `) 来替代参数名，但是如果已经使用下划线来省略参数时，是不能使用 `it` 来替代当前参数的

- Lambda 最后一条语句的执行结果表示这个 Lambda 的返回值

- [一个例子](https://antonioleiva.com/functional-programming-android-kotlin-lambdas/)来看用 Lambda 如何精简代码

  ```kotlin
  // toast 函数是 Anko 库的一个方法
  view.setOnClickListener(object : OnClickListener {
      override fun onClick(v: View) {
          toast("clicked")
      }
  })
  // 可以先将 setOnClickListener() 优化成：
  // View 是作为参数传入，而返回值是 Unit (nothing)
  fun setOnClickListener(listener: (View) -> Unit)
  // 我们可以将设置监听的代码简化为：
  view.setOnClickListener({view -> toast("clicked")})
  // 假如我们不需要用到传入参数的话，可以进一步简化：
  view.setOnClickListener({toast("clicked")})
  // 如果参数函数（作为参数的函数）是函数的最后一个参数，可以将它移到参数的小括号外边：
  view.setOnClickListener(){ toast("clicked") }
  // 如果参数函数是函数的唯一一个参数，可以去掉参数小括号：
  view.setOnClickListener {toast("clicked")}
  ```

## 可见性修饰符 Visibility modifiers

- `private` : 只在包含声明的文件中可见
- `protected` : 在 top-level 声明中不可用
- `internal` : 在同一个 module 中可见
- `public` : 默认值，任何地方都可见

## interface 接口

- Kotlin 的接口可以包含方法的实现，这一点与 Java 不同
- 在接口中如果没有函数体，那么默认是抽象的

## 变量

- 变量可以很简单地定义成 可变 `var` 和不可变 `val` 的变量。这个与 Java 中使用的 `final` 很相似
- 一个不可变对象意味着它在实例化之后就不能再去改变它的状态了。如果你需要一个这个对象修改之后的版本，那就会再创建一个新的对象
- 不可变对象也可以说是线程安全的，因为它们无法去改变，也不需要去定义访问控制，因为所有线程访问到的对象都是同一个
- 一个重要的概念是：尽可能地使用 `val`
- 在 `data class` 中，如果参数中使用了 `val` 来定义，那么在通过构造函数创建实例时，如果不给使用 `val` 来定义的参数赋值的话，`val` 有可能为 `null`（添加了 `?`） 或者为默认值

### 空值检测

- `println(files?.size)`  这句代码之后在 `files` 不为空时执行

## 集合 (Collection)

- 在 Kotlin 中，集合类一般不使用构造方法去初始化，而是使用同一的入口方法
- Kotlin 中的 `List` 与 Java 中的 `List` 并不一样

## 函数

- 函数可以直接设置默认参数: `fun say(str: String = "hi")`
- 可以给一个参数指定默认值使这个参数变成  “`optional`”。因此可以使用这种形式来在方法或者构造函数中避免为了使用参数默认值而去 *重载*

```kotlin
// Sample
fun niceToast(message: String,
                tag: String = javaClass<MainActivity>().getSimpleName(),
                length: Int = Toast.LENGTH_SHORT) {
    Toast.makeText(this, "[tag] $message", length).show()
}

// 可以通过以下方式调用
toast("Hello")
toast("Hello", "MyTag")
toast("Hello", "MyTag", Toast.LENGTH_SHORT)

// 甚至还可以使用参数名字来调用
toast(message = "Hello", length = Toast.LENGTH_SHORT)
```
### 构造函数

- 分为==主构造函数==和==次构造函数==
- 如有 **注解 (annotation)** 需要加上关键字 `constructor`
- 在构造函数中声明的参数默认为 `public`，如果不希望其他类访问到这个变量可以使用 `private` 来修饰
- `init` 块：在主构造函数中不能有任何代码实现，如有此需求要放到 `init` 块中执行
- 如果一个非抽象类没有声明任何(主或次)构造函数，它会有一个生成的不带参数的主构造函数
- 构造函数默认是 public 的
- 如果你不希望你的类 有一个公有构造函数,你需要声明一个带有非默认可见性的空的主构造函数 `class myClass private constructor () {  }`
- 在 JVM 上,如果主构造函数的所有的参数都有默认值，编译器会生成一个额外的无参构造函数,它将使用默认值
- 次级构造函数需要用 `constructor` 声明。次级构造函数不能直接将参数转换为字段

### 变参函数

> 在 Kotlin 中，变长参数用 `vararg` 关键字表示

```java
    // java
    public boolean hasEmpty(String... strArray) { 
        //... 
    }

    // kotlin
    fun hasEmpty(vararg strArray: String?): Boolean { 
        // ...
    }
```

### 扩展函数 

> 给父类添加一个方法，这个方法将可以在它以及它所有的子类中使用

- 一般在 top level 定义拓展（使用 Kotlin file）

```kotlin
    fun Activity.toast(message: CharSequence, duration: Int = Toast.LENGTH_SHORT) {
        Toast.makeText(this, message, duration).show()
    }

    // 此后可以直接在 Activity 中调用
    toast("hello kotlin")

```

==注意，扩展方法是静态解析的，并不是真正给类添加了方法==

```kotlin
    open class Animal {
    }

    class Dog: Animal() 

    object Main {
        fun Animal.bark() = "animal"
        fun Dog.bark() = "dog"

        fun Animal.printBark(anim: Animal) {
            println(anim.bark())
        }

        @JvmStatic fun main(args: Array<String>) {
            Animal().printBark(Dog()) // "animal"
        }
    }

```

### 嵌套函数

> Kotlin 的一个特性，在函数中在声明函数。与内部类有些类似，内部函数可以直接访问外部函数的局部变量、常量，而外部函数不能访问到内部函数。通常使用在 *会在某些条件下触发递归的方法内* 或者是 *不希望外部其他函数访问到的函数*，在一般情况下是不推荐使用嵌套函数的

```kotlin
    fun sample() {
        val str = "Hello!"

        fun say(count: Int = 10) {
            println(str)
            if (count > 0) {
                say(count - 1)
            }
        }
        say()
    }
```

### 高阶函数

> 当定义一个闭包作为参数的函数，称为高阶函数

### 内联函数

> 它可以大幅提升高阶函数的性能

### 闭包

- 自执行闭包：在定义闭包的同时直接执行闭包，一般用于初始化上下文环境

    ```kotlin
    { x: Int, y: Int ->
        println("${x + y}")    
    }(1, 3)
    ```
- 闭包不能有变长参数
- 闭包虽然有强大的灵活性，可以省略很多临时变量和参数声明。但是滥用的话，可以会写出可读性非常差的代码

## 类

- 默认任何类都是基础继承自 `Any` (与java中的 `Object` 类似)
- Kotlin 的所有类在默认情况下都是 `final` ，即不可继承，除非是 `abstract` 的类。如果想要一个类可以被继承，需要使用 `open`
- 需要重写被继承类的方法，需要使用 `override`，被继承类的该方法需要用 `open` 注解，如果不想==再==被重写，在 `override` 前多添加一个 `final`
- Kotlin 中，每个枚举常量都是一个对象
- `is` 判断一个对象是否是某个类的实例，`as` 用来强转
- 如果 smart cast(智能转换) 的对象是一个全局变量，这个变量可能在别的地方被改变赋值，所以必须手动判断与转换它的类型

```kotlin
    open class Animal {
    }
    class Dog: Animal {
        fun bark() = println("animal")
    }

    var animal: Animal? = null

    fun main(args: Array<String>) {

        if (animal is Dog) {
            // 并不满足执行的条件，所以不会执行以下语句
            (animal as Dog).bark()
        }
    }
```

### 抽象类 (abstract)

- 不需要用 `open` 来声明类

### 泛型 (Generics)

#### out 关键字

在所有方法中，只能返回 type `E` 并且不能将任何 `E` 类型作为参数

#### in 关键字

在所有方法中，可以将 `T` 作为参数，但不能返回 `T` type

### 单例类 - Singleton

```kotlin
    // 类被调用的时候才去初始化它的对象
    // 推荐写法
    class Single private constructor() {
        companion object {
            fun get(): Single {
                return Holder.instance
            }
        }

        private object Holder {
            val instance = Single()
        }
    }
```

#### 关于单例的更多资料：

- [很多人推荐的单例文章 -- Kotlin singletons with argument](https://medium.com/@BladeCoder/kotlin-singletons-with-argument-194ef06edd9e)

### 匿名内部类

> 在 Java 中的匿名内部类（anonymous inner classes）在 Kotlin 中会使用 对象表达式（object expressions）或者对象声明（object declarations）来替代

```kotlin
window.addMouseListener(object : MouseAdapter() {
    override fun mouseClicked(e: MouseEvent) {
        // ...
    }
    
    override fun mouseEntered(e: MouseEvent) {
        // ...
    }
})
```
### 数据类 - data class

- 如果要数据类含有无参的构造函数，需要为每个属性设置默认值

#### 额外的函数

1. `copy()`

```kotlin
// 如果需要修改 Forecast 中的 temperature 
val f1 = Forecast(Date(), 27.5f, "Shiny day")
val f2 = f1.copy(temperature = 30f)
```
### 多声明

```kotlin
val f1 = Forecast(Date(), 27.5f, "Shiny day")
val (date, temperature, details) = f1

// 上面这个多声明会被编译成以下代码
val date = f1.date
val temperature = f1.temperature
val details = f1.details
```

### 动态代理

> Kotlin 原生支持动态代理

## 对象

- 对象的其中一个功能是相当于 Java 中匿名内部类的用法（比如在设置监听回调的时候，使用 `object expression` 来代替 Java 中的匿名内部类）

### companion object

> 伴生对象

## 与 Java 的交互

- 关于 `Class` 的调用，在 M13 之前，Java 中的 `myJava.class` 对应 Kotlin 中的 `JavaClass<myJava>`，而 M13 之后写法已经变为 `myJava::class.java`

- Kotlin 中没有 `static` 关键字，如果在 Java 中想要通过雷鸣调用一个 Kotlin 的方法，就需要给这个方法加入 `@JvmStatic` 注解。否则就必须结合 `Companion` 来调用方法

## 集合

- 在 Kotlin 中，集合类一般不使用构造方法去初始化，而是使用同一的入口方法

### 操作符

> Kotlin 的操作符跟 RxJava 基本一致，本质是方法调用

#### 常用操作符

1. 下标操作符
- contains
- elementAt
- firstOrNull
- lastOrNull
- indexOf
- singleOrNull

2. 判断类
- any
- all
- none
- count
- reduce

3. 过滤类
- filter
- filterNot
- filterNotNull
- take

4. 转换类
- map
- mapIndexed
- mapNotNull
- flatMap
- groupBy

5. 排序类
- reversed
- sorted
- sortedBy
- sortedDescending

## 异常处理

> Kotlin 中没有异常检查

## 与 Java 的交互

- 关于 `Class` 的调用，在 M13 之前，Java 中的 `myJava.class` 对应 Kotlin 中的 `JavaClass<myJava>`，而 M13 之后写法已经变为 `myJava::class.java`
- Kotlin 中没有 `static` 关键字，如果在 Java 中想要通过雷鸣调用一个 Kotlin 的方法，就需要给这个方法加入 `@JvmStatic` 注解。否则就必须结合 `Companion` 来调用方法

##  编码风格

- 不要给属性前面加前缀，比如 `m` 或者 下划线等

## 其他资源

### Anko

- Anko是JetBrains开发的一个强大的库。它主要的目的是用来替代以前XML的方式来使用代码生成UI布局。Anko包含了很多的非常有帮助的函数和属性来避免让你写很多的模版代码。
- 任何时候你使用了Anko库中的某些东西，它们都会以属性名、方法等方式被导入。这是因为Anko使用了扩展函数在Android框架中增加了一些新的功能。
- Anko能帮助我们简化代码，比如，实例化Intent，Activity之间的跳转，Fragment的创建，数据库的访问，Alert的创建……

### Kotlin 学习系列

- 关于常量 [Where Should I Keep My Constants in Kotlin?](https://blog.egorand.me/where-do-i-put-my-constants-in-kotlin/)
- 关于单例 Singleton [Kotlin singletons with argument](https://medium.com/@BladeCoder/kotlin-singletons-with-argument-194ef06edd9e)
- 正则表达式 [Regular Expressions in Kotlin](http://www.baeldung.com/kotlin-regular-expressions)
- [Idiomatic Kotlin. Best Practices](https://blog.philipphauer.de/idiomatic-kotlin-best-practices/)